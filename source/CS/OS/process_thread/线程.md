

# 线程

## 用户态线程和内核态线程模型

### 1. 用户线程 (User-Level Thread, ULT)

用户线程完全在**用户空间**中创建和管理。操作系统内核完全不知道这些线程的存在，它只看到一个“进程”。

- **模型**：**多对一 (Many-to-One)**。多个用户线程映射到一个内核线程（或进程）。
- **优点**：
  - **极速切换**：线程切换不需要进入内核态，没有系统调用开销。
  - **灵活性高**：可以在不支持线程的旧系统中实现，调度算法由程序员自定义。
- **缺点**：
  - **一堵全堵**：如果一个线程发起了阻塞式系统调用（如磁盘读取），内核会挂起整个进程，导致所有线程都停止运行。
  - **无法并行**：因为内核只分配一个 CPU 给进程，所以无法在多核 CPU 上同时运行多个用户线程。

------

### 2. 内核线程 (Kernel-Level Thread, KLT)

内核线程由**操作系统内核**直接管理。内核为每个线程维护上下文信息，并负责调度。

- **模型**：**一对一 (One-to-One)**。每个用户线程对应一个独立的内核实体（Linux 的 NPTL 库就是这种模式）。
- **优点**：
  - **真并发**：多个线程可以被调度到不同的 CPU 核心上，实现真正的并行计算。
  - **互不干扰**：一个线程阻塞不会影响同一进程中的其他线程。
- **缺点**：
  - **开销较大**：每次创建、销毁或切换线程都需要进行用户态和内核态的切换（系统调用），消耗资源较多。

------

### 3. 混合线程 (Hybrid Threading)

结合了上述两者的优点。用户空间有一套线程库，内核空间也有内核线程支持，两者通过多对多的方式映射。

- **模型**：**多对多 (Many-to-Many)**。
- **优点**：
  - **效率与并发兼得**：开发者可以创建大量用户线程，而内核只调度适量的内核线程来承载它们。
  - **避免阻塞**：如果某个用户线程被阻塞，内核可以将其映射到的内核线程暂时挂起，并调度另一个内核线程来执行其他用户线程。
- **典型案例**：早期的一些 UNIX 系统（如 Solaris）和现代的 Go 语言（其 **Goroutine** 实际上就是一种在用户态实现的、高度优化的混合调度模型）。

------

### 核心区别总结表

| **特性**     | **用户线程 (ULT)**   | **内核线程 (KLT)**    | **混合线程 (Hybrid)** |
| ------------ | -------------------- | --------------------- | --------------------- |
| **映射关系** | 多对一 (N:1)         | 一对一 (1:1)          | 多对多 (M:N)          |
| **管理位置** | 用户空间 (线程库)    | 内核空间 (OS)         | 两者共同协作          |
| **切换速度** | 极快 (无需陷入内核)  | 较慢 (涉及上下文切换) | 介于两者之间          |
| **阻塞影响** | 一个阻塞，全进程阻塞 | 互不影响              | 部分影响/可动态调整   |
| **多核利用** | 无法利用多核         | 完美利用多核          | 完美利用多核          |

###