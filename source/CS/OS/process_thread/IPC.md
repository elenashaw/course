# 进程间通信（IPC）

> 笔记参考资料： Modern Operating Systems(by Andrew Tanenbaum)

## 背景介绍

### IPC的三个方面

### 竞争条件

### 问题定义（临界区）

#### 问题定义

#### 好的解决方案需要满足的条件

### 两个重要的问题

#### 生产者-消费者问题（读写问题）

#### 哲学家就餐问题



## IPC问题解决方案

*注意：下文所称“首次引入某概念”，仅指MOS一书在讲解/推导中的首次出现，并不意味着该概念在历史上首次提出或首次使用*

### 早期尝试方案

#### 屏蔽中断（disable interrupt)

**试图解决的问题**

​	在多个进程并发访问共享数据时，**防止多个进程同时进入临界区**，从而避免竞态条件（race condition）

**方法**

​	在进入临界区之前，**临时关闭 CPU 的中断响应**，使当前执行流在执行期间不会被中断；在离开临界区后，再重新开启中断。

**本质手段**

​	通过**禁止中断触发上下文切换**，保证当前处理器在执行临界区进程时不被其他进程抢占，从而实现互斥访问。

**漏洞与不足**

* 只适用于单核处理器, 不适用于多核处理器

  * 屏蔽中断只能阻止当前 CPU 被打断

  * 在多核系统中，其他 CPU 仍可并发访问共享数据

* 系统响应性差

  * 时钟中断无法触发
  * 调度器无法运行
  * I/O 事件得不到处理
  * 系统表现为“假死”

* 不适用于用户态程序

  * 用户程序不允许关闭中断，这种方法只适用于内核态

**该方法依赖的隐含前提**

* 系统是单核的

* 被保护代码执行时间极短

* 执行者可信



#### 锁变量（Lock Variables）

**试图解决的问题**

​	防止多个进程同时进入临界区

**方法**

​	引入一个**共享变量（lock）**

```markdown
lock = 0
: 表示临界区空闲

lock = 1
: 表示临界区已被占用
```



**代码逻辑**

```c
while(lock==1);
lock=1; //占用
critical_region();//临界区操作
lock=0; //进程完成操作释放锁变量
```

**本质手段**

​	使用软件共享状态变量来表达**临界区占用状态**

**创新点和新概念**

* 不依赖关闭中断
* 首次尝试将“互斥”抽象为一个**共享变量**
* 概念上独立于硬件，这是**软件**方法

**漏洞与不足**

*  读-改-写不是原子操作，**仍然无法避免竞争条件**

  * 和假脱机目录问题一样，当一个进程A读取锁变量的值, 结果为lock==0时，恰好要执行 

    ```c
    lock=1;
    ```

    之前，另一个进程B被调度运行。进程B也想要进入临界区，读取到未修改的锁变量值为lock==0。因而有两个进程同时进入临界区



#### 严格轮换法

**试图解决的问题**

​	防止多个进程同时进入临界区

**方法**

​	引入一个共享变量 `turn`（取值通常为 0/1），规定“**轮到谁，谁才能进入临界区**”。每次离开临界区时，进程把 `turn` 交给对方

**代码逻辑**

* 进程0

```c
while (true) {            // 循环
    while (turn != 0) ;   // 忙等，直到轮到自己
    critical_region();    // 进程0进入临界区
    turn = 1;             // 结束临界区操作，将权限给进程1
    noncritical_region(); // 回到非临界区
}
```



* 进程1

```c
while (true) {            // 循环
    while (turn != 1) ;   // 忙等，直到轮到自己
    critical_region();    // 进程1进入临界区
    turn = 1;             // 结束临界区操作，将权限给进程0
    noncritical_region(); // 回到非临界区
}
```



**本质手段**

​	用**强制交替执行顺序**替代锁

**新概念**

* 忙等待（busy waiting）: 连续测试一个变量，直到某个值出现

  * 例如：``` while (turn != 1)```
  * 通常地，浪费CPU时间
    * 应当避免

* 自旋锁（Spinlock）: 自旋锁是一种利用忙等待实现的互斥锁

  * 例如: ```while (test_and_set(lock)) {// spin}```

  * 在锁持有时间**极短**的情况下**，忙等待比上下文切换更高效**

    * 忙等待开销：消耗 **CPU 时间片**
    * 上下文切换开销：涉及保存当前进程的寄存器、堆栈信息，切换到内核态，再加载另一个进程的运行环境

    

**漏洞与不足**

* 违反了“进程被临界区外的另一个进程阻塞” 的标准
  * 若turn轮到进程1，但进程1长期不进入临界区，进程0即使急需进入临界区也必须等待

* 忙等待（Busy Waiting）浪费 CPU时间
  * `while (turn != i) ;` 会持续占用 CPU 周期，竞争激烈或等待长时效率极差。
* 单一且极其严格的公平标准，导致**自适应性差**
  * 严格轮换法没有考虑两个进程分别占用临界区的时长，访问临界区的频率等的差异



### 忙等待互斥（Busy-wait Mutual Exclusion）

#### Peterson解法

**试图解决的问题**

​	通过软件实现两个进程间的严格互斥，且允许一个进程在对方不想进入临界区时连续进入

**方法**

​	引入一个数组 `flag[2]` 表示进程是否想进入临界区的意愿，以及一个变量 `turn` 表示当前轮到谁

**代码逻辑**

```c
#define FALSE 0
#define TRUE 1
#define N

int turn;
int interested[N];   //两个人各自持有一个数据
void enter_region(int process){
    int other;  //表示另一个进程
    other=1-process;
    interested[process]=TRUE;  //该进程表示感兴趣
    turn=process; //后到者标记，如果只有一个到，那么就是想要访问者（逻辑上也是后到者）。其他写法中，turn代表允许进入的那个人，是把权限给对方，但本质都是turn的串行覆盖
    while(turn==process&&interested[other]==TRUE);//while忙等待，这里就是后到者等待的体现，可以理解为，我是后到者，且对方感兴趣的时候等等
}

void leave_region(int process){
    interested[process]=FALSE;
}

```



**本质手段**

​	意愿，谦让（后到者等待）和裁决

**创新点与新概念**	

- 后到者等待：turn的串行覆盖
- 纯软件互斥（不依赖硬件原子操作

**漏洞与不足**

- 忙等待：仍属于**自旋锁（Spinlock）**，在等待期间持续消耗 CPU 资源
- 仅限双进程
- 优先级翻转问题：若高优先级进程在忙等待低优先级进程，可能导致低优先级进程无法获得 CPU 来退出临界区，从而引发系统死锁。
  - 具体过程：由于 H 的优先级更高，调度器一直让 H 运行（在 `while` 循环里自旋）。而 L 因为优先级低，得不到 CPU 时间片，也就无法执行 `leave_region` 来释放锁
- 现代硬件的失效（指令重排）：由于 `interested[process] = TRUE;` 和 `turn = process;` 之间没有逻辑依赖，现代 CPU 为了性能可能会**先写 `turn` 再写 `interested`**。如果两个 CPU 都这么干，两个进程可能同时跳过 `while` 循环进入临界区，导致算法完全失效



#### TSL指令

**试图解决的问题**

​	读-改-写（Read-Modify-Write）的原子性，多核处理器的互斥

**方法**

* **硬件支持**：引入一条专用的硬件指令 `TSL RX, LOCK`。

* **物理锁定**：执行指令时，CPU 会锁定**内存总线**，确保该内存单元在指令结束前不会被其他CPU访问

**代码逻辑**

```c
// 进程进入临界区的逻辑：
enter_region:
    TSL REGISTER, LOCK      // 【原子操作】将LOCK读入寄存器并设为1
    CMP REGISTER, #0        // 旧值是0吗？(0表示之前没锁)
    JNE enter_region        // 如果不是0，说明有人占用，跳回重新测试(忙等待)
    RET                     // 成功进入

leave_region:
    MOVE LOCK, #0           // 释放锁
    RET
```



**本质手段**

* 硬件原子性：将“读取并检查”与“设置占用”这两个动作通过硬件电路合并为一个原子操作。

- 强制串行化：通过锁定总线，在**物理层面上强制所有 CPU** 必须排队访问该变量。

**创新点与新概念**

- **原子操作（Atomic Operation）**：指不可被中断的操作，是并发编程的基础。

- **硬件锁支持**：将互斥的实现从“复杂的软件算法”简化为“单一的硬件功能”。

**漏洞与不足**

- 忙等待：仍属于**自旋锁（Spinlock）**，在等待期间持续消耗 CPU 资源
- 优先级翻转问题:  若高优先级进程在自旋等待低优先级进程，可能导致低优先级进程永远无法获得 CPU 来释放锁，从而引发死锁

- 性能瓶颈: 在多核系统中，频繁锁定总线会导致内存性能显著下降



### 生产者-消费者问题（有界缓冲区问题

#### 问题描述和分析

- 问题描述

  - 两组并发进程（生产者与消费者）通过一个容量为 $N$ 的有限缓冲区 交换信息
- **本质：并发同步模型**
  * 多进程访问**有状态共享缓冲区**，需要**互斥（一致访问）+ 条件同步（状态满足约束时执行）**

* 消费者问题的约束
  * **互斥约束**：缓冲区及其状态变量（如 `count`）是临界资源，操作必须具备**原子性**
  
  * **秩序约束**：
    
    * 生产者：仅当 count < N 时执行 produce
      * 若count=N, 若想produce则睡眠
    * 消费者：仅当 count > 0 时执行 consume
      * 若count=0, 若想consume则睡眠


- 和之前的临界区问题的区别

  - | 维度         | 临界区问题（Critical Section） | 生产者–消费者问题                  |
    | ------------ | ------------------------------ | ---------------------------------- |
    | **问题类型** | 竞争                           | **协作**                           |
    | **核心关注** | 谁能进                         | 什么时候进、进了干什么             |
    | **资源模型** | 单一、瞬时资源（一段代码）     | 有状态资源（有限缓冲区）           |
    | **约束来源** | 同时访问会出错                 | 顺序/数量不满足会出错              |
    | **必要机制** | 互斥（Mutual Exclusion）       | **互斥 + 同步（Synchronization）** |
    | **失败后果** | 竞争条件                       | 逻辑错误（空取 / 溢出）            |




#### 为什么这一章在这儿？

- 从“静态互斥”到**“动态同步**”的跃迁
  - Peterson/TSL 解决准入控制，但忽略生产/消费速度不匹配（e.g., 快产慢消导致溢出）
  - 引入同步机制处理动态状态变化


* **忙等待算法的缺陷**：

  * **CPU浪费**：轮询空转，占用时片，降低多任务效率。

  * **性能低下**：频繁检查引发上下文切换/锁竞争，高负载下吞吐量下降。

  * **优先级反转**：低优先级进程长时间持锁，阻塞高优先级执行，实时系统风险高。

  * **公平性/饥饿**：无队列，高活跃进程反复抢占，低活跃者长期等待。

    **能源高耗**：持续CPU活动，增加功耗，不适移动/绿色环境。



### 阻塞式同步

#### 睡眠和唤醒

**试图解决的问题**

​	忙等待的CPU浪费与低效；条件协作

**方法**

* sleep():

  * sleep() 是原子操作，不会阻塞其他进程

  * 和忙等待的区别

    * 忙等待是原地循环，一直占用CPU。直到符合条件，进程主动跳出循环

      * ```c
        while (count == 0); 
        ```

    * 睡眠是进程被切换到阻塞态/睡眠态，进入等待队列，不会一直占用CPU。直到被另一个进程唤醒

      * ```c
        if(count==0) sleep();
        ```

* wakeup(process)

**代码逻辑**

* ```c
  #define N 100               /* 缓冲区中的槽位数量 */
  int count = 0;              /* 缓冲区中的项目数量 */
  
  void producer(void)
  {
      int item;
      while (TRUE) {          /* 无限循环 */
          item = produce_item();             /* 生成下一个项目 */
          
          if (count == N) sleep();           /* 如果缓冲区满了，进入睡眠 */
          
          insert_item(item);                 /* 将项目放入缓冲区 */
          count = count + 1;                 /* 缓冲区项目计数加 1 */
          
          if (count == 1) wakeup(consumer);  /* 如果缓冲区从空变为 1，唤醒消费者 */
      }
  }
  
  void consumer(void)
  {
      int item;
      while (TRUE) {          /* 无限循环 */
          if (count == 0) sleep();           /* 如果缓冲区是空的，进入睡眠 */
          
          item = remove_item();              /* 从缓冲区中取出一个项目 */
          count = count - 1;                 /* 缓冲区项目计数减 1 */
          
          if (count == N - 1) wakeup(producer); /* 如果缓冲区从满变为有空位，唤醒生产者 */
          
          consume_item(item);                /* 处理（打印）该项目 */
      }
  }
  ```

* 代码注意事项：

  * count==N
    * 为什么不是count>=N
      * 如果代码运行正确，`count` 的值永远不会超过 `N`。因此，`== N` 和 `>= N` 在逻辑判断上是等价的
      * 如果count>N, 那么程序出现bug

  * count=\=1
    * 为什么不是count>=1
      * 如果在count>=1时进行唤醒（在情景上就是生产一次就唤醒一次），就会重复唤醒，显然不合理
      * 只有当缓冲区从 **0 变到 1** 的那一瞬间，生产者才需要发出“唤醒”指令
      * **这决定了这个算法只适用于单生产者单消费者的情形**
      
    * count==N-1同理，不过=\=N-1是槽满了以后被消费一次的时候唤醒
  
  * **只使用于单生产者单消费者的情形**
  
    


**本质手段**

* **状态切换：** 将进程从“就绪态（Ready）”强制转变为“阻塞态（Blocked）”。
* **调度干预：** 放弃 CPU 控制权，由内核管理进程的等待队列，直到明确的唤醒信号到达

**创新点与新概念**

* 非忙等待（睡眠/唤醒）

* 信号丢失补偿的思考： 它引入了对“唤醒信号是否应该被存起来”的思考（这直接导向了后来的**信号量 Semaphore** 概念）。

**漏洞与不足**：

竞态条件

* 原因：对count的访问未加限制

* 本质：wakeup唤醒信号丢失

* 唤醒丢失过程：

  1. 消费者检查 `count` 发现是 0。
  2. 此时时钟中断，操作系统切换到生产者。
  3. 生产者放入一个产品，`count` 变成 1。因为 `count` 之前是 0，生产者调用 `wakeup(consumer)`。
  4. **关键点：** 此时消费者还没真正“入睡”（它刚检查完条件，还没执行 `sleep`），所以这个唤醒信号发送给了一个清醒的进程，**信号丢失了**。
  5. 轮到消费者运行时，它继续执行刚才的 `sleep()`，陷入沉睡。
  6. 生产者继续生产直到填满缓冲区，也进入沉睡。
  7. **结果：** 两个进程都永远地睡下去了，系统死锁。

* 一个不太好的解决方案（补丁）

  * 设置一个唤醒等待位


不适用于多消费者多生产者的问题



#### 信号量semaphore

**试图解决的问题**

* 解决了唤醒信号丢失的问题
* 解决了外部计数器count访问不被限制的问题（改成自带的计数器
* 解决了多生产者多消费者协作的问题

**方法**

信号量是一个特殊的**整型**变量 $S$，它只能通过两个**原子操作**（Atomic Operations）来访问：

- **P 操作（Wait / Down）：**
  -  尝试获取资源。检查值是否大于 0。若大于 0 则减 1 并继续；若为 0 则进程睡眠，此时 P操作未结束。
  - 荷兰语：Proberen(尝试)
- **V 操作（Signal / Up）：** 
  - 释放资源。将值加 1；若有进程在等待，则由系统选择一个唤醒，此时值仍为 0，但睡眠进程减少一个。
  - Verhogen（增加

信号量的原子操作过程包含：**检查数值、修改变量值，以及可能发生的睡眠操作**。操作系统在进行原子操作时，进行**暂时的屏蔽中断**，如果是多个cpu，那么需要TSL或者XCHG确保只有一个CPU在进行修改

**代码逻辑**

```c
#define N 100             /*槽的数目*/
typedef int semaphore;
semaphore mutex = 1;      /* 初值为1，用于互斥访问临界区,确保生产者和霞飞这不会同时访问 */
semaphore empty = N;      /* 初值为N，记录空槽数目 */
semaphore full = 0;       /* 初值为0，记录满槽数目 */

void producer(void) {
    int item;
    while (TRUE) {
        item = produce_item();
        down(&empty);     /* 递减空槽数，若无空槽则阻塞 */
        down(&mutex);     /* 进入临界区 */
        insert_item(item);
        up(&mutex);       /* 离开临界区 */
        up(&full);        /* 递增满槽数，唤醒可能的消费者 */
    }
}

void consumer(void) {
    int item;
    while (TRUE) {
        down(&full);      /* 递减满槽数，若无产品则阻塞 */
        down(&mutex);     /* 进入临界区 */
        item = remove_item();
        up(&mutex);       /* 离开临界区 */
        up(&empty);       /* 递增空槽数，唤醒可能的生产者 */
        consume_item(item);
    }
}
```

* 代码注意事项

  * up()/down()函数通常作为系统调用

  * 可以理解为，down是消耗资源，而up是释放资源。

  * ```c
    void down(semaphore *s) {
        /* 整个过程是原子的，由硬件（如TSL）或屏蔽中断保护 */
        if (s->value > 0) {
            // 如果有保存下来的唤醒信号，直接消耗它
            s->value = s->value - 1;
        } else {
            // 如果值为0，进程进入睡眠，且down操作尚未结束
            // 进程被放入该信号量的等待队列中
            sleep_on(s);
        }
    }
    void up(semaphore *s) {
        /* 整个过程是原子的 */
        if (any_process_sleeping_on(s)) {
            // 如果有进程在等待，唤醒其中一个（如随机挑选）
            // 此时s->value保持为0，但睡眠进程减少一个
            wakeup_one_process_from(s);
        } else {
            // 如果没有进程在睡眠，则增加信号量的值
            // 这代表“保存”了一个唤醒操作供以后使用
            s->value = s->value + 1;
        }
    }
    ```

  * Sleep on Semaphore

    * 在某个信号量的资源不够了，在这里阻塞

**本质手段**

* **信号记忆（State Memory）**
  * 通过信号量的值来保存“尚未被处理的唤醒操作”，使信号不再是瞬时的。 传统的 `sleep/wakeup` 会产生“唤醒丢失”问题，因为如果唤醒信号发出时进程还没睡下，信号就丢了。

* **原子操作**

**创新点与新概念**

* 信号量
  * **二值信号量 (Binary Semaphore)：** 值只有 0 和 1。类似于互斥锁（Mutex），但有区别（Mutex 强调所有权，谁加锁谁解锁；Semaphore 强调信号，A 进程可以唤醒 B 进程）。
  * **计数信号量 (Counting Semaphore)：** 值可以大于 1，用于管理多个同类资源（如连接池、车位管理）。
* 原语/原子操作

**漏洞与不足**

* 嵌套顺序严格，如果误用P,V,或者嵌套顺序错了，没有成对出现就会有死锁风险
* 优先级反转
* 结构化程度低（相对于管程



#### 互斥量

**试图解决的问题**

**方法**

**代码逻辑**

**本质手段**

**创新点与新概念**

**漏洞与不足**



阻塞式同步原语（Blocking Synchronization Primitives）

结构化同步（Structured Concurrency Constructs）

无共享内存/分布式 IPC（Shared-nothing IPC）

群体同步与特化优化

**试图解决的问题**

**方法**

**代码逻辑**

**本质手段**

**创新点与新概念**

**漏洞与不足**