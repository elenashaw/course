# 进程间通信（IPC）

> 笔记参考资料： Modern Operating Systems(by Andrew Tanenbaum)

## 背景介绍

### IPC的三个方面

### 竞争条件

### 问题定义（临界区）

#### 问题定义

#### 好的解决方案需要满足的条件

### 两个重要的问题

#### 生产者-消费者问题（读写问题）

#### 哲学家就餐问题



## IPC问题解决方案

*注意：下文所称“首次引入某概念”，仅指MOS一书在讲解/推导中的首次出现，并不意味着该概念在历史上首次提出或首次使用*

### 早期尝试方案

#### 屏蔽中断（disable interrupt)

**试图解决的问题**

​	在多个进程并发访问共享数据时，**防止多个进程同时进入临界区**，从而避免竞态条件（race condition）

**方法**

​	在进入临界区之前，**临时关闭 CPU 的中断响应**，使当前执行流在执行期间不会被中断；在离开临界区后，再重新开启中断。

**本质手段**

​	通过**禁止中断触发上下文切换**，保证当前处理器在执行临界区进程时不被其他进程抢占，从而实现互斥访问。

**漏洞与不足**

* 只适用于单核处理器, 不适用于多核处理器

  * 屏蔽中断只能阻止当前 CPU 被打断

  * 在多核系统中，其他 CPU 仍可并发访问共享数据

* 系统响应性差

  * 时钟中断无法触发
  * 调度器无法运行
  * I/O 事件得不到处理
  * 系统表现为“假死”

* 不适用于用户态程序

  * 用户程序不允许关闭中断，这种方法只适用于内核态

**该方法依赖的隐含前提**

* 系统是单核的

* 被保护代码执行时间极短

* 执行者可信



#### 锁变量（Lock Variables）

**试图解决的问题**

​	防止多个进程同时进入临界区

**方法**

​	引入一个**共享变量（lock）**

```markdown
lock = 0
: 表示临界区空闲

lock = 1
: 表示临界区已被占用
```



**代码逻辑**

```c
while(lock==1);
lock=1; //占用
critical_region();//临界区操作
lock=0; //进程完成操作释放锁变量
```

**本质手段**

​	使用软件共享状态变量来表达**临界区占用状态**

**创新点和新概念**

* 不依赖关闭中断
* 首次尝试将“互斥”抽象为一个**共享变量**
* 概念上独立于硬件，这是**软件**方法

**漏洞与不足**

*  读-改-写不是原子操作，**仍然无法避免竞争条件**

  * 和假脱机目录问题一样，当一个进程A读取锁变量的值, 结果为lock==0时，恰好要执行 

    ```c
    lock=1;
    ```

    之前，另一个进程B被调度运行。进程B也想要进入临界区，读取到未修改的锁变量值为lock==0。因而有两个进程同时进入临界区



#### 严格轮换法

**试图解决的问题**

​	防止多个进程同时进入临界区

**方法**

​	引入一个共享变量 `turn`（取值通常为 0/1），规定“**轮到谁，谁才能进入临界区**”。每次离开临界区时，进程把 `turn` 交给对方

**代码逻辑**

* 进程0

```c
while (true) {            // 循环
    while (turn != 0) ;   // 忙等，直到轮到自己
    critical_region();    // 进程0进入临界区
    turn = 1;             // 结束临界区操作，将权限给进程1
    noncritical_region(); // 回到非临界区
}
```



* 进程1

```c
while (true) {            // 循环
    while (turn != 1) ;   // 忙等，直到轮到自己
    critical_region();    // 进程1进入临界区
    turn = 1;             // 结束临界区操作，将权限给进程0
    noncritical_region(); // 回到非临界区
}
```



**本质手段**

​	用**强制交替执行顺序**替代锁

**新概念**

* 忙等待（busy waiting）: 连续测试一个变量，直到某个值出现

  * 例如：``` while (turn != 1)```
  * 通常地，浪费CPU时间
    * 应当避免

* 自旋锁（Spinlock）: 自旋锁是一种利用忙等待实现的互斥锁

  * 例如: ```while (test_and_set(lock)) {// spin}```

  * 在锁持有时间**极短**的情况下**，忙等待比上下文切换更高效**

    * 忙等待开销：消耗 **CPU 时间片**
    * 上下文切换开销：涉及保存当前进程的寄存器、堆栈信息，切换到内核态，再加载另一个进程的运行环境

    

**漏洞与不足**

* 违反了“进程被临界区外的另一个进程阻塞” 的标准
  * 若turn轮到进程1，但进程1长期不进入临界区，进程0即使急需进入临界区也必须等待

* 忙等待（Busy Waiting）浪费 CPU时间
  * `while (turn != i) ;` 会持续占用 CPU 周期，竞争激烈或等待长时效率极差。
* 单一且极其严格的公平标准，导致**自适应性差**
  * 严格轮换法没有考虑两个进程分别占用临界区的时长，访问临界区的频率等的差异



### 忙等待互斥（Busy-wait Mutual Exclusion）

#### Peterson解法

**试图解决的问题**

​	通过软件实现两个进程间的严格互斥，且允许一个进程在对方不想进入临界区时连续进入

**方法**

​	引入一个数组 `flag[2]` 表示进程是否想进入临界区的意愿，以及一个变量 `turn` 表示当前轮到谁

**代码逻辑**

```c
#define FALSE 0
#define TRUE 1
#define N

int turn;
int interested[N];   //两个人各自持有一个数据
void enter_region(int process){
    int other;  //表示另一个进程
    other=1-process;
    interested[process]=TRUE;  //该进程表示感兴趣
    turn=process; //后到者标记，如果只有一个到，那么就是想要访问者（逻辑上也是后到者）。其他写法中，turn代表允许进入的那个人，是把权限给对方，但本质都是turn的串行覆盖
    while(turn==process&&interested[other]==TRUE);//while忙等待，这里就是后到者等待的体现，可以理解为，我是后到者，且对方感兴趣的时候等等
}

void leave_region(int process){
    interested[process]=FALSE;
}

```



**本质手段**

​	意愿，谦让（后到者等待）和裁决

**创新点与新概念**	

- 后到者等待：turn的串行覆盖
- 纯软件互斥（不依赖硬件原子操作

**漏洞与不足**

- 忙等待：仍属于**自旋锁（Spinlock）**，在等待期间持续消耗 CPU 资源
- 仅限双进程
- 优先级翻转问题：若高优先级进程在忙等待低优先级进程，可能导致低优先级进程无法获得 CPU 来退出临界区，从而引发系统死锁。
  - 具体过程：由于 H 的优先级更高，调度器一直让 H 运行（在 `while` 循环里自旋）。而 L 因为优先级低，得不到 CPU 时间片，也就无法执行 `leave_region` 来释放锁
- 现代硬件的失效（指令重排）：由于 `interested[process] = TRUE;` 和 `turn = process;` 之间没有逻辑依赖，现代 CPU 为了性能可能会**先写 `turn` 再写 `interested`**。如果两个 CPU 都这么干，两个进程可能同时跳过 `while` 循环进入临界区，导致算法完全失效



#### TSL指令

**试图解决的问题**

​	读-改-写（Read-Modify-Write）的原子性，多核处理器的互斥

**方法**

* **硬件支持**：引入一条专用的硬件指令 `TSL RX, LOCK`。

* **物理锁定**：执行指令时，CPU 会锁定**内存总线**，确保该内存单元在指令结束前不会被其他CPU访问

**代码逻辑**

```c
// 进程进入临界区的逻辑：
enter_region:
    TSL REGISTER, LOCK      // 【原子操作】将LOCK读入寄存器并设为1
    CMP REGISTER, #0        // 旧值是0吗？(0表示之前没锁)
    JNE enter_region        // 如果不是0，说明有人占用，跳回重新测试(忙等待)
    RET                     // 成功进入

leave_region:
    MOVE LOCK, #0           // 释放锁
    RET
```



**本质手段**

* 硬件原子性：将“读取并检查”与“设置占用”这两个动作通过硬件电路合并为一个原子操作。

- 强制串行化：通过锁定总线，在**物理层面上强制所有 CPU** 必须排队访问该变量。

**创新点与新概念**

- **原子操作（Atomic Operation）**：指不可被中断的操作，是并发编程的基础。

- **硬件锁支持**：将互斥的实现从“复杂的软件算法”简化为“单一的硬件功能”。

**漏洞与不足**

- 忙等待：仍属于**自旋锁（Spinlock）**，在等待期间持续消耗 CPU 资源
- 优先级翻转问题:  若高优先级进程在自旋等待低优先级进程，可能导致低优先级进程永远无法获得 CPU 来释放锁，从而引发死锁

- 性能瓶颈: 在多核系统中，频繁锁定总线会导致内存性能显著下降



### 生产者-消费者问题（读写问题

#### 问题描述和分析

- 问题描述

  - 两组并发进程（生产者与消费者）通过一个容量为 $N$ 的有限缓冲区 交换信息
- **本质：并发同步模型**
  * 多进程访问**有状态共享缓冲区**，需要**互斥（一致访问）+ 条件同步（状态满足约束时执行）**

* 消费者问题的约束
  * **互斥约束**：缓冲区及其状态变量（如 `count`）是临界资源，操作必须具备**原子性**
  
  * **秩序约束**：
    
    * 生产者：仅当 count < N 时执行 produce
    
      消费者：仅当 count > 0 时执行 consume


- 和之前的临界区问题的区别

  - | 维度         | 临界区问题（Critical Section） | 生产者–消费者问题                  |
    | ------------ | ------------------------------ | ---------------------------------- |
    | **问题类型** | 竞争                           | **协作**                           |
    | **核心关注** | 谁能进                         | 什么时候进、进了干什么             |
    | **资源模型** | 单一、瞬时资源（一段代码）     | 有状态资源（有限缓冲区）           |
    | **约束来源** | 同时访问会出错                 | 顺序/数量不满足会出错              |
    | **必要机制** | 互斥（Mutual Exclusion）       | **互斥 + 同步（Synchronization）** |
    | **失败后果** | 竞争条件                       | 逻辑错误（空取 / 溢出）            |




#### 为什么这一章在这儿？

- 从“静态互斥”到**“动态同步**”的跃迁
  - Peterson/TSL 解决准入控制，但忽略生产/消费速度不匹配（e.g., 快产慢消导致溢出）
  - 引入同步机制处理动态状态变化


* **忙等待算法的缺陷**：

  * **CPU浪费**：轮询空转，占用时片，降低多任务效率。

  * **性能低下**：频繁检查引发上下文切换/锁竞争，高负载下吞吐量下降。

  * **优先级反转**：低优先级进程长时间持锁，阻塞高优先级执行，实时系统风险高。

  * **公平性/饥饿**：无队列，高活跃进程反复抢占，低活跃者长期等待。

    **能源高耗**：持续CPU活动，增加功耗，不适移动/绿色环境。



### 阻塞式同步

#### 睡眠和唤醒

**试图解决的问题**

​	忙等待的CPU浪费与低效；条件协作

**方法**

**代码逻辑**

**本质手段**

**创新点与新概念**

**漏洞与不足**



#### 信号量



阻塞式同步原语（Blocking Synchronization Primitives）

结构化同步（Structured Concurrency Constructs）

无共享内存/分布式 IPC（Shared-nothing IPC）

群体同步与特化优化

**试图解决的问题**

**方法**

**代码逻辑**

**本质手段**

**创新点与新概念**

**漏洞与不足**