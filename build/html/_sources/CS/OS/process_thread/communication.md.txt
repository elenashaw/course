# 进程间通信（IPC）

> 笔记参考资料： Modern Operating Systems(by Andrew Tanenbaum)

## 背景介绍

### IPC的三个方面

### 竞争条件

### 问题定义（临界区）

#### 问题定义

#### 好的解决方案需要满足的条件

### 两个重要的问题

#### 生产者-消费者问题（读写问题）

#### 哲学家就餐问题



## IPC问题解决方案

*注意：下文所称“首次引入某概念”，仅指MOS一书在讲解/推导中的首次出现，并不意味着该概念在历史上首次提出或首次使用*

### 早期尝试方案

#### 屏蔽中断（disable interrupt)

**试图解决的问题**

​	在多个进程并发访问共享数据时，**防止多个进程同时进入临界区**，从而避免竞态条件（race condition）

**方法**

​	在进入临界区之前，**临时关闭 CPU 的中断响应**，使当前执行流在执行期间不会被中断；在离开临界区后，再重新开启中断。

**本质手段**

​	通过**禁止中断触发上下文切换**，保证当前处理器在执行临界区进程时不被其他进程抢占，从而实现互斥访问。

**漏洞与不足**

* 只适用于单核处理器, 不适用于多核处理器

  * 屏蔽中断只能阻止当前 CPU 被打断

  * 在多核系统中，其他 CPU 仍可并发访问共享数据

* 系统响应性差

  * 时钟中断无法触发
  * 调度器无法运行
  * I/O 事件得不到处理
  * 系统表现为“假死”

* 不适用于用户态程序

  * 用户程序不允许关闭中断，这种方法只适用于内核态

**该方法依赖的隐含前提**

* 系统是单核的

* 被保护代码执行时间极短

* 执行者可信



#### 锁变量（Lock Variables）

**试图解决的问题**

​	防止多个进程同时进入临界区

**方法**

​	引入一个**共享变量（lock）**

```markdown
lock = 0
: 表示临界区空闲

lock = 1
: 表示临界区已被占用
```



**代码逻辑**

```c
while(lock==1);
lock=1; //占用
critical_region();//临界区操作
lock=0; //进程完成操作释放锁变量
```

**本质手段**

​	使用软件共享状态变量来表达**临界区占用状态**

**创新点和新概念**

* 不依赖关闭中断
* 首次尝试将“互斥”抽象为一个**共享变量**
* 概念上独立于硬件，这是**软件**方法

**漏洞与不足**

*  读-改-写不是原子操作，**仍然无法避免竞争条件**

  * 和假脱机目录问题一样，当一个进程A读取锁变量的值, 结果为lock==0时，恰好要执行 

    ```c
    lock=1;
    ```

    之前，另一个进程B被调度运行。进程B也想要进入临界区，读取到未修改的锁变量值为lock==0。因而有两个进程同时进入临界区



#### 严格轮换法

**试图解决的问题**

​	防止多个进程同时进入临界区

**方法**

​	引入一个共享变量 `turn`（取值通常为 0/1），规定“**轮到谁，谁才能进入临界区**”。每次离开临界区时，进程把 `turn` 交给对方

**代码逻辑**

* 进程0

```c
while (true) {            // 循环
    while (turn != 0) ;   // 忙等，直到轮到自己
    critical_region();    // 进程0进入临界区
    turn = 1;             // 结束临界区操作，将权限给进程1
    noncritical_region(); // 回到非临界区
}
```



* 进程1

```c
while (true) {            // 循环
    while (turn != 1) ;   // 忙等，直到轮到自己
    critical_region();    // 进程1进入临界区
    turn = 1;             // 结束临界区操作，将权限给进程0
    noncritical_region(); // 回到非临界区
}
```



**本质手段**

​	用**强制交替执行顺序**替代锁

**新概念**

* 忙等待（busy waiting）: 连续测试一个变量，直到某个值出现

  * 例如：``` while (turn != 1)```
  * 通常地，浪费CPU时间
    * 应当避免

* 自旋锁（Spinlock）: 自旋锁是一种利用忙等待实现的互斥锁

  * 例如: ```while (test_and_set(lock)) {// spin}```

  * 在锁持有时间**极短**的情况下**，忙等待比上下文切换更高效**

    * 忙等待开销：消耗 **CPU 时间片**
    * 上下文切换开销：涉及保存当前进程的寄存器、堆栈信息，切换到内核态，再加载另一个进程的运行环境

    

**漏洞与不足**

* 违反了“进程被临界区外的另一个进程阻塞” 的标准
  * 若turn轮到进程1，但进程1长期不进入临界区，进程0即使急需进入临界区也必须等待

* 忙等待（Busy Waiting）浪费 CPU时间
  * `while (turn != i) ;` 会持续占用 CPU 周期，竞争激烈或等待长时效率极差。
* 单一且极其严格的公平标准，导致**自适应性差**
  * 严格轮换法没有考虑两个进程分别占用临界区的时长，访问临界区的频率等的差异



### 忙等待互斥（Busy-wait Mutual Exclusion）

#### Peterson解法

**试图解决的问题**

**方法**

**代码逻辑**

**本质手段**

**创新点与新概念**

**漏洞与不足**



阻塞式同步原语（Blocking Synchronization Primitives）

结构化同步（Structured Concurrency Constructs）

无共享内存/分布式 IPC（Shared-nothing IPC）

群体同步与特化优化

**试图解决的问题**

**方法**

**代码逻辑**

**本质手段**

**创新点与新概念**

**漏洞与不足**