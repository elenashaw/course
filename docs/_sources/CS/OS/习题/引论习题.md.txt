---

tags: [OS, Computer-Architecture, Quiz] 

category: Modern Operating Systems 

---



> 选自Modern Operating Systems, Fourth Edition, by Andrew S. Tanenbaum



(mos-ch1-q4)=

## 第四题：Cache 行（Cache Line）的设计优势

为了使用高速缓存，主存被划分为若干cache行，通常每行长32或64字节。每次缓存一整个cache行。每次缓存一整行而不是一个字节或一个字，这样做的优点是什么？

* ***利用空间局部性：** 程序通常会访问相邻的内存地址，将一整行载入 Cache 可以显著提高后续访问的**命中率**。
* **提高总线传输效率：** 主存与 Cache 之间的块交换能充分利用**突发传输模式**，提高带宽利用率，减少多次请求带来的握手开
* **降低硬件维护成本：** 以行为单位存储可以减少 Cache 标签（Tag）的数量，简化地址映射逻辑。



(mos-ch1-q6)=

## 第六题：特权指令与 I/O 访问

与访问I/O设备相关的指令通常是特权指令，也就是说，它们能在内核态执行而在用户态则不行。说明为什么这些指令是特权指令。

- **保护系统安全与隐私：** I/O 设备（如磁盘、键盘、网卡）属于全局共享资源。如果允许用户程序直接执行 I/O 指令，恶意程序就能绕过权限直接读取他人的文件或监听键盘输入。通过设为特权指令，所有 I/O 操作必须由**内核**代为执行，内核会在操作前检查进程是否有相应权限。
  
- **防止硬件冲突与资源争用：** 许多 I/O 设备在同一时刻只能由一个进程使用（如打印机）。如果多个用户程序同时直接向硬件发送指令，会导致数据混乱甚至硬件损坏。内核作为“管家”，通过特权指令统一接收请求并进行排队管理，确保了设备访问的有序性。
  
- **提高系统调度效率（回应学生的阻塞点）：** I/O 操作通常比 CPU 慢得多。通过将 I/O 限制在内核态，当阻塞发生时，内核能**立即感知**并主动将当前进程挂起（切入等待态），将 CPU 资源分配给其他就绪进程，从而防止 CPU 因为等待某个用户程序的 I/O 响应而处于“盲等”状态。

举个手机使用例子

| **手机操作**     | **计算机底层术语**            | **严谨的物理/逻辑发生过程**                                            |
| ------------ | ---------------------- | ----------------------------------------------------------- |
| APP 正在滤镜处理   | **用户态 (User Mode)**    | CPU 仅执行算术逻辑指令。如果此时 APP 试图强行读闪存，硬件会触发“非法指令”异常直接关闭 APP。       |
| APP 点击“打开相册” | **系统调用 (System Call)** | APP 执行 `SVC` (iOS) 或 `INT` 指令触发 **Trap**，CPU 状态位由用户态切换为内核态。 |
| **系统核对权限**   | **内核态下的权限检查**          | 内核查询权限数据库。**若无授权且是首次申请**，内核挂起该 APP，切换到 UI 进程弹出确认框。          |
| 用户点击“允许”     | **状态恢复与调度**            | 内核记录授权，将 APP 从“阻塞态”恢复。                                      |
| 读取照片数据流      | **特权模式执行 (Ring 0)**    | CPU 在内核态下，由驱动程序发出 **I/O 特权指令**（如读写 I/O 端口/寄存器），真正从闪存拉取数据。   |



(mos-ch1-q10)=

## 第十题：内核态 vs 用户态

内核态和用户态有哪些区别？解释在设计操作系统时存在两种不同的模式有什么帮助。

**区别：**

| **维度**      | **用户态 (User Mode)**                  | **内核态 (Kernel Mode)**                    |
| ----------- | ------------------------------------ | ---------------------------------------- |
| **指令权限**    | **受限**。只能执行非特权指令。如果尝试执行特权指令，会触发硬件异常。 | **完全权限**。可以执行所有指令，包括特权指令（如 I/O 控制、中断处理）。 |
| **内存访问**    | 只能访问分配给该进程的**用户空间地址**，受硬件保护。         | 可以访问系统的**所有内存空间**（包括内核代码、数据及所有进程空间）。     |
| **运行角色**    | 运行应用程序（如浏览器、办公软件、手机 APP）。            | 运行操作系统的核心（内核），直接管理硬件资源。                  |
| **CPU 状态位** | CPU 中的模式位（Mode Bit）通常为 1（代表低特权级）。    | CPU 中的模式位（Mode Bit）通常为 0（代表最高特权级）。       |

**设计两种不同模式对操作系统的帮助**

 1. 保护系统**安全**（防范恶意与错误）

	通过限制特权指令，防止普通程序直接控制硬件或读取其他进程的数据。
	
2. 提升系统**稳定性**（故障隔离）

	在用户态运行的程序即使发生崩溃（如死循环或内存越界），只会导致该进程被关闭，而不会导致整个操作系统宕机。
   
3. 实现资源公平**调度**（防止独占）

	内核态下的特权指令可以控制**时钟中断**。即使一个用户程序卡死了，内核也能通过时钟中断强制夺回 CPU 控制权（切换到内核态），然后调度其他进程运行。
   
4. 屏蔽底层细节（**硬件抽象**）

	用户态程序无需关心具体的硬件寄存器和握手协议。开发者只需调用简单的系统接口（系统调用），复杂的硬件控制由内核在内核态下安全、高效地完成。



(mos-ch1-q10)=

## 第十五题: 平均存储访问时间 (AMAT) 计算

假设一个计算机系统有高速缓存、内存 (RAM) 以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要 1ns，RAM 需要 10ns，磁盘需要 10ms。如果缓存的命中率是 95%，内存的是 99% (缓存失效时)，读取一个词的平均时间是多少？

- **已知条件：**
  
    - $T_{cache} = 1\text{ ns}$，命中率 $H_1 = 95\%$
      
    - $T_{ram} = 10\text{ ns}$，命中率 $H_2 = 99\%$ (在缓存未命中前提下)
      
    - $T_{disk} = 10\text{ ms} = 10,000,000\text{ ns}$
    
- **计算公式：**
  
    $$
    AMAT=t1+m1×t2+(m1×m2)×t3​
    $$
    
- **计算过程：**
  
    - 直接命中缓存：$0.95 \times 1\text{ ns}$
      
    - 缓存未命中 ($1 - 0.95 = 0.05$)，但内存命中：$0.05 \times 0.99 \times 10\text{ ns}$
      
    - 缓存与内存皆未命中 ($0.05 \times 0.01$)，需读取磁盘：$0.05 \times 0.01 \times 10,000,000\text{ ns}$
        $$T_{avg} = (0.95 \times 1) + (0.05 \times 0.99 \times 10) + (0.05 \times 0.01 \times 10,000,000)$$
        $$T_{avg} = 0.95 + 0.495 + 5000 = 5001.445\text{ ns}$$​
	
	    > [!note]
	    >
	    > AMAT是个简化模型，具体请参考COA->层次化存储->AMAT



(mos-ch1-q17)=

## 第十七题: 陷阱指令 (Trap Instruction)

什么是陷阱指令？在操作系统中解释它的用途

- ### 1. 陷阱指令的定义 (Definition)

  **陷阱指令**（又称**访管指令**或**自愿中断指令**）是一种特殊的处理器指令，它通过触发一个**同步异常**（Synchronous Exception），使处理器主动从**用户态**（User Mode）切换到**内核态**（Kernel Mode）。

  - **执行本质**：它不是一种出错导致的意外，而是程序员在代码中显式编写的指令，旨在**“自愿**”进入内核空间。
  - **硬件行为**：执行该指令时，CPU 会自动完成以下操作：**保存**当前的程序状态（如 PC 指针、寄存器），提升特权等级，并根据**中断向量表**跳转到预设的**内核处理程序入口**。

  

  ### 2. 在操作系统中的用途 (Purposes)

  #### A. 实现系统调用 (System Call Interface) —— **最主要用途**

  由于硬件保护机制，用户程序无法直接执行特权指令（如操作硬盘、分配物理内存）。陷阱指令充当了用户程序与内核之间的**唯一合法接口**。

  - **例子**：当程序需要打印文字到屏幕时，会调用 `printf()`，其底层最终执行一条陷阱指令，请求内核代为操作显示器。

  #### B. 权限切换与安全保护 (Privilege Transition & Security)

  陷阱指令提供了一种**受控的**特权提升方式。

  - 它确保用户**不能随意跳转到内核**的任意位置执行代码，而只能跳转到内核**指定的“门”或“服务例程”**。这防止了恶意软件通过直接访问内存或硬件来破坏系统。

  #### C. 软件调试与错误处理 (Debugging & Error Handling)

  - **断点设置**：调试器（如 GDB）通过在目标代码中**插入陷阱指令**来**实现“断点”**。当程序运行到此处，会产生陷阱并把控制权交给调试器，允许查看变量状态。
  - **程序监控**：当程序执行了某些**非法操作**（如除零）时，硬件也会触发类似陷阱的机制（有时统称为异常），让操作系统接管并优雅地处理。

  >  [!note]
  >
  > (os-exception)=
  >
  > **异常（exception）**
  >
  > * **异常**是指 CPU 在执行指令过程中检测到的、由于指令执行本身引起的“不寻常”事件。
  >
  > | **类别**         | **产生原因**         | **例子**                 | **恢复行为 (返回地址)**                                      |
  > | ---------------- | -------------------- | ------------------------ | ------------------------------------------------------------ |
  > | **Trap (陷阱)**  | **指令有意触发**     | 系统调用、程序断点       | **返回下一条指令**：处理完后，CPU 执行 Trap 之后的指令。     |
  > | **Fault (故障)** | **指令潜在错误**     | 缺页异常、分段错误       | **重新执行当前指令**：修复环境后（如把页调入内存），CPU 会尝试再次运行报错的那条指令。 |
  > | **Abort (终止)** | **不可恢复硬件错误** | RAM 奇偶校验错、总线错误 | **无法返回**：程序状态已损坏，操作系统通常直接终止该进程。   |
  >
  > 
  >
  > **中断（Interrupt）**与异常的对比
  >
  > | **特性**     | **异常 (Exception / Internal Interrupt)** | **中断 (Interrupt / External Interrupt)**      |
  > | ------------ | ----------------------------------------- | ---------------------------------------------- |
  > | **来源**     | **CPU 内部**（当前执行的指令）。          | **CPU 外部**（外部设备，如键盘、磁盘、时钟）。 |
  > | **同步性**   | **同步**。与指令执行节奏一致。            | **异步**。随时可能发生，与当前指令无关。       |
  > | **典型例子** | 陷阱 (Trap)、故障 (Fault)、终止 (Abort)。 | 键盘输入、磁盘 I/O 完成、时钟脉冲。            |
  > | **处理逻辑** | 必须由当前指令的处理流程来响应。          | CPU 在执行完当前指令后，检查中断引脚。         |
  >
  > 

  

  

  